# Graphic Study Demo

## 介绍

这是一个基于 SDL2 的图形学学习演示项目，用于理解和实现基础的光栅化算法。

## 软件架构

- 使用 SDL2 创建窗口和处理底层图形操作
- 从零实现像素级光栅化算法
- 支持基础的几何图元渲染（点、线、三角形等）

## 安装教程

运行演示程序：`./start.sh`

## 使用说明

1. ESC键或关闭窗口退出程序
2. 修改 `drew()` 函数来实现自定义光栅化算法
3. 使用 `setPixel()` 函数直接操作像素

## 笔记

### Bresenham 直线算法的向量化推导

#### 基于几何投影与整数优化的框架

#### 1. 向量化问题建模

设直线起点为 $P_0(x_0,y_0)$，终点为 $P_1(x_1,y_1)$，定义方向向量：

$$d = (dx, dy) = (x_1-x_0, y_1-y_0)$$

直线的隐式方程可表示为法向量形式：

$$F(x,y) = n \cdot (P-P_0) = dy(x-x_0) - dx(y-y_0) = 0$$

其中法向量 $n = (dy, -dx)$，垂直于方向向量 $d$。

#### 2. 步进方向选择

主方向判定：

- 若 $|dx| > |dy|$，则 x 轴为主方向
- 否则，y 轴为主方向

定义步进基向量：

- 主方向基向量 $e_m$：沿主轴方向的单位步进
- 次方向基向量 $e_s$：沿次轴方向的单位步进

当 x 为主方向时：$e_m = (1,0)$，$e_s = (0,1)$  
当 y 为主方向时：$e_m = (0,1)$，$e_s = (1,0)$

#### 3. 几何误差的向量解释

当前点 $P(x,y)$ 到直线的有符号距离：

$$D = \frac{F(x,y)}{|n|} = \frac{dy(x-x_0) - dx(y-y_0)}{\sqrt{dx^2+dy^2}}$$

为了避免浮点运算，我们关注的是误差的符号而非精确大小，因此定义缩放误差：

$$ε = 2 \cdot F(x,y) = 2[dy(x-x_0) - dx(y-y_0)]$$

乘以2是为了在后续步骤中避免除以2的运算。

#### 4. 误差更新的直观推导

##### 情况A：x 为主方向 (|dx| > |dy|)

假设当前点为 $P(x,y)$，误差为 $ε$。考虑两种可能的移动：

**移动1：沿 x 轴移动到 $(x+1,y)$**

$$\begin{align}
ε_{新} &= 2 \cdot F(x+1,y) \\
&= 2[dy((x+1)-x_0) - dx(y-y_0)] \\
&= 2[dy(x-x_0) + dy - dx(y-y_0)] \\
&= 2 \cdot F(x,y) + 2dy \\
&= ε + 2dy
\end{align}$$

**移动2：沿对角线移动到 $(x+1,y+1)$**

$$\begin{align}
ε_{新} &= 2 \cdot F(x+1,y+1) \\
&= 2[dy((x+1)-x_0) - dx((y+1)-y_0)] \\
&= 2[dy(x-x_0) + dy - dx(y-y_0) - dx] \\
&= 2 \cdot F(x,y) + 2dy - 2dx \\
&= ε + 2dy - 2dx
\end{align}$$

##### 情况B：y 为主方向 (|dy| > |dx|)

当 y 为主方向时，考虑两种可能的移动：

**移动1：沿 y 轴移动到 $(x,y+1)$**

$$\begin{align}
ε_{新} &= 2 \cdot F(x,y+1) \\
&= 2[dy(x-x_0) - dx((y+1)-y_0)] \\
&= 2[dy(x-x_0) - dx(y-y_0) - dx] \\
&= 2 \cdot F(x,y) - 2dx \\
&= ε - 2dx
\end{align}$$

**移动2：沿对角线移动到 $(x+1,y+1)$**

$$\begin{align}
ε_{新} &= 2 \cdot F(x+1,y+1) \\
&= 2[dy((x+1)-x_0) - dx((y+1)-y_0)] \\
&= 2[dy(x-x_0) + dy - dx(y-y_0) - dx] \\
&= 2 \cdot F(x,y) + 2dy - 2dx \\
&= ε + 2dy - 2dx
\end{align}$$

#### 5. 决策规则与统一的算法

**当 x 为主方向时：**
- 如果 $ε < 0$，选择对角线移动，更新 $ε += 2dy - 2dx$
- 否则，选择沿 x 轴移动，更新 $ε += 2dy$

**当 y 为主方向时：**
- 如果 $ε > 0$，选择对角线移动，更新 $ε += 2dy - 2dx$
- 否则，选择沿 y 轴移动，更新 $ε -= 2dx$

为了统一处理这两种情况，Bresenham 算法使用了一个巧妙的技巧：

```cpp
int e2 = 2 * err;
if (e2 > -dy) {  // 决定是否在 x 方向步进
    err -= dy;   // 更新误差
    x0 += sx;    // x 坐标步进
}
if (e2 < dx) {   // 决定是否在 y 方向步进
    err += dx;   // 更新误差
    y0 += sy;    // y 坐标步进
}
```

这两个条件的几何含义是：
- `e2 > -dy` 判断理想直线是否在当前点的"上方"
- `e2 < dx` 判断理想直线是否在当前点的"右方"

通过这两个条件，算法能够自适应地处理不同斜率和不同象限的直线绘制。

#### 6. 与代码的对应关系

在代码实现中，我们使用 `err = dx - dy` 作为初始误差。这样设置的好处是：

- 当 x 为主方向时，`err` 初始值为正，符合我们的误差模型
- 当 y 为主方向时，`err` 初始值为负，需要反转误差解释

这解释了为什么算法能够统一处理所有情况：

```cpp
// 初始化误差
int err = dx - dy;

// 主循环
while (true) {
    setPixel(x0, y0, r, g, b);

    if (x0 == x1 && y0 == y1) break;

    int e2 = 2 * err;
    // 无论主方向是什么，这两个条件都适用
    if (e2 > -dy) { err -= dy; x0 += sx; }
    if (e2 < dx) { err += dx; y0 += sy; }
}
```

#### 7. 完整算法实现

```cpp
void drawLine(int x0, int y0, int x1, int y1, Uint8 r, Uint8 g, Uint8 b) {
    int dx = abs(x1 - x0);
    int dy = abs(y1 - y0);
    int sx = (x0 < x1) ? 1 : -1;
    int sy = (y0 < y1) ? 1 : -1;
    int err = dx - dy;

    while (true) {
        setPixel(x0, y0, r, g, b);

        if (x0 == x1 && y0 == y1) break;

        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}
```

通过这种统一的方式，Bresenham 算法能够处理任意斜率和方向的直线绘制，而且全部在整数域内完成计算。

### Bresenham 算法推广到圆形和椭圆

Bresenham 直线算法的核心思想可以推广到圆形和椭圆的绘制。

#### 1. Bresenham 中点圆算法

##### 1.1 数学基础

圆的隐式方程：

$$F(x, y) = x^2 + y^2 - r^2 = 0$$

其中 $r$ 是圆的半径。类似于直线算法，我们可以用误差函数来决定选择哪个像素：

$F(x, y) = 0$ 表示点在圆上
$F(x, y) < 0$ 表示点在圆内
$F(x, y) > 0$ 表示点在圆外

##### 1.2 算法推导

由于圆的对称性，我们只需要计算第一个八分圆弧（即 $x \geq 0$ 且 $y \geq 0$ 且 $x \geq y$），其余部分可以通过对称变换得到。

在第一个八分圆弧中，我们从 $(0, r)$ 开始，向右下方向移动，每次要么向右移动，要么向右下移动。对于当前点 $(x_k, y_k)$，下一个点可能是：

- $(x_k+1, y_k)$ - 向右移动
- $(x_k+1, y_k-1)$ - 向右下移动

中点判别式：计算点 $(x_k+1, y_k-\frac{1}{2})$ 相对于圆的位置

$$p_k = F(x_k+1, y_k-\frac{1}{2}) = (x_k+1)^2 + (y_k-\frac{1}{2})^2 - r^2$$

决策规则：
- 如果 $p_k < 0$（中点在圆内），选择 $(x_k+1, y_k)$
- 如果 $p_k \geq 0$（中点在圆上或圆外），选择 $(x_k+1, y_k-1)$

###### 1.2.1 递推公式与代码实现的对应

在实际编码时，我们先更新坐标再更新决策参数，这会影响递推公式的形式。为理解代码中的更新公式，我们需要考虑变量更新的顺序：

**情况1:** 当 $p_k < 0$ 时，选择 $(x_k+1, y_k)$

理论递推关系：
$$p_{k+1} = (x_k+2)^2 + (y_k-\frac{1}{2})^2 - r^2$$

展开得：
$$\begin{align}
p_{k+1} &= (x_k+1+1)^2 + (y_k-\frac{1}{2})^2 - r^2 \\
&= (x_k+1)^2 + 2(x_k+1) + 1 + (y_k-\frac{1}{2})^2 - r^2 \\
&= p_k + 2(x_k+1) + 1
\end{align}$$

在代码中，我们先执行 `x++`，此时 $x$ 已经是 $x_{k+1} = x_k + 1$。
因此，更新公式中使用的是 $x_{k+1}$ 而不是 $x_k$：

$$\begin{align}
p_{k+1} &= p_k + 2(x_k+1) + 1 \\
&= p_k + 2x_{k+1} + 1
\end{align}$$

这对应代码中的 `p += 2 * x + 1`。

**情况2:** 当 $p_k \geq 0$ 时，选择 $(x_k+1, y_k-1)$

理论递推关系：
$$p_{k+1} = (x_k+2)^2 + (y_k-1-\frac{1}{2})^2 - r^2$$

展开得：
$$\begin{align}
p_{k+1} &= (x_k+1+1)^2 + (y_k-1-\frac{1}{2})^2 - r^2 \\
&= (x_k+1)^2 + 2(x_k+1) + 1 + (y_k-\frac{1}{2}-1)^2 - r^2 \\
\end{align}$$

进一步展开 $(y_k-\frac{1}{2}-1)^2$：
$$\begin{align}
(y_k-\frac{1}{2}-1)^2 &= ((y_k-\frac{1}{2})-1)^2 \\
&= (y_k-\frac{1}{2})^2 - 2(y_k-\frac{1}{2}) + 1 \\
&= (y_k-\frac{1}{2})^2 - 2y_k + 1 + 1 \\
&= (y_k-\frac{1}{2})^2 - 2y_k + 2
\end{align}$$

代入原式：
$$\begin{align}
p_{k+1} &= (x_k+1)^2 + 2(x_k+1) + 1 + (y_k-\frac{1}{2})^2 - 2y_k + 2 - r^2 \\
&= p_k + 2(x_k+1) + 1 - 2y_k + 2 \\
&= p_k + 2x_k + 2 + 1 - 2y_k + 2 \\
&= p_k + 2x_k - 2y_k + 5
\end{align}$$

在代码中，我们先执行 `x++`，再执行 `y--`，此时 $x = x_{k+1} = x_k + 1$ 且 $y = y_{k+1} = y_k - 1$。
因此 $x_k = x_{k+1} - 1$ 且 $y_k = y_{k+1} + 1$，代入：

$$\begin{align}
p_{k+1} &= p_k + 2x_k - 2y_k + 5 \\
&= p_k + 2(x_{k+1}-1) - 2(y_{k+1}+1) + 5 \\
&= p_k + 2x_{k+1} - 2 - 2y_{k+1} - 2 + 5 \\
&= p_k + 2x_{k+1} - 2y_{k+1} + 1 \\
&= p_k + 2(x_{k+1} - y_{k+1}) + 1
\end{align}$$

这正是代码中的 `p += 2 * (x - y) + 1`。

###### 1.2.2 初始决策参数的推导

对于起点 $(0, r)$，第一个需要决策的中点是 $(1, r-\frac{1}{2})$。

根据决策参数定义：
$$p_0 = F(1, r-\frac{1}{2}) = 1^2 + (r-\frac{1}{2})^2 - r^2$$

展开计算：
$$\begin{align}
p_0 &= 1 + (r-\frac{1}{2})^2 - r^2 \\
&= 1 + r^2 - r + \frac{1}{4} - r^2 \\
&= 1 - r + \frac{1}{4}
\end{align}$$

为避免浮点运算，实际实现中通常使用 `p = 1 - r` 作为近似的初始值。这个近似不会影响算法的正确性，因为：

1. 我们只关心决策参数的符号而非精确值
2. 后续的递推公式保持正确，确保算法整体精度
3. 对于整数半径的圆，这个初始值提供足够准确的初始判断

例如，当 $r = 5$ 时：
- 严格计算值：$p_0 = 1 - 5 + 0.25 = -3.75$ (负数)
- 代码中使用：$p_0 = 1 - 5 = -4$ (同样为负数)

两者会导致相同的第一步决策（选择向右移动），因此算法行为完全一致。

##### 1.3 算法实现
```cpp
void drawCircle(int xc, int yc, int r, Uint8 red, Uint8 green, Uint8 blue) {
    int x = 0;
    int y = r;
    int p = 1 - r;  // 初始决策参数，也可以推导为此值

    // 绘制初始点
    plotCirclePoints(xc, yc, x, y, red, green, blue);

    while (x < y) {
        x++;  // 先增加 x（对应 x_{k+1} = x_k + 1）

        // 决策参数更新
        if (p < 0) {
            p += 2 * x + 1;  // 使用更新后的 x 值
        } else {
            y--;  // 减少 y（对应 y_{k+1} = y_k - 1）
            p += 2 * (x - y) + 1;  // 使用更新后的 x 和 y 值
        }

        // 利用圆的八重对称性绘制所有八个点
        plotCirclePoints(xc, yc, x, y, red, green, blue);
    }
}
```
